"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBuiltinModule = void 0;
/**
 * Load a Node built-in module. ID may or may not be prefixed by `node:` and
 * will be normalized. If we used static imports then our bundle size would be bloated by
 * injected polyfills, and if we used dynamic require then in addition to bundlers logging warnings,
 * our code would not work when bundled to ESM and run in Node 18.
 * @param {string} id ID of the built-in to be loaded.
 * @returns {object|undefined} exports of the built-in. Undefined if the built-in
 * does not exist.
 */
let getBuiltinModule = function getBuiltinModuleLazy(id) {
    try {
        if (exports.getBuiltinModule !== getBuiltinModuleLazy)
            return exports.getBuiltinModule(id);
        if (process.getBuiltinModule) {
            exports.getBuiltinModule = process.getBuiltinModule;
        }
        else {
            /* Fallback implementation for Node 18 */
            function createFallbackGetBuiltinModule(BuiltinModule) {
                return function getBuiltinModule(id) {
                    id = BuiltinModule.normalizeRequirableId(String(id));
                    if (!BuiltinModule.canBeRequiredByUsers(id)) {
                        return;
                    }
                    const mod = BuiltinModule.map.get(id);
                    mod.compileForPublicLoader();
                    return mod.exports;
                };
            }
            const magicKey = Math.random() + '';
            let module;
            let ObjectPrototype = Blob;
            for (let next; (next = Reflect.getPrototypeOf(ObjectPrototype)); ObjectPrototype = next)
                ;
            try {
                const kClone = Object.getOwnPropertySymbols(Blob.prototype).find((e) => e.description?.includes('clone'));
                Object.defineProperty(ObjectPrototype, magicKey, {
                    get() {
                        module = this;
                        throw null;
                    },
                    configurable: true,
                });
                structuredClone(new (class extends Blob {
                    [kClone]() {
                        return {
                            deserializeInfo: 'internal/bootstrap/realm:' + magicKey,
                        };
                    }
                })([]));
            }
            catch { }
            delete ObjectPrototype[magicKey];
            if (module) {
                exports.getBuiltinModule = createFallbackGetBuiltinModule(module.BuiltinModule);
            }
            else {
                exports.getBuiltinModule = () => undefined;
            }
        }
        return exports.getBuiltinModule(id);
    }
    catch {
        return undefined;
    }
};
exports.getBuiltinModule = getBuiltinModule;
//# sourceMappingURL=getBuiltinModule.js.map